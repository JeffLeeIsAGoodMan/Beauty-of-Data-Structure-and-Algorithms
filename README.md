# 数据结构与算法之美

在 [极客时间](https://time.geekbang.org/) 上买的课程，但打开的交互路径太长，所以转到其他地方来看。  

---

* [开篇词 | 从今天起，跨过“数据结构与算法”这道坎](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/1)
* [01 | 为什么要学习数据结构和算法？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/2)
* [02 | 如何抓住重点，系统高效地学习数据结构与算法？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/3)
* [03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/4)
* [04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/5)
* [不定期福利第一期 | 数据结构与算法学习书单](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/6)
* [05 | 数组：为什么很多编程语言中数组都从0开始编号？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/7)
* [06 | 链表（上）：如何实现LRU缓存淘汰算法?](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/8)
* [07 | 链表（下）：如何轻松写出正确的链表代码？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/9)
* [08 | 栈：如何实现浏览器的前进和后退功能？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/10)
* [09 | 队列：队列在线程池等有限资源池中的应用](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/11)
* [10 | 递归：如何用三行代码找到“最终推荐人”？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/12)
* [11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/13)
* [12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/14)
* [13 | 线性排序：如何根据年龄给100万用户数据排序？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/15)
* [14 | 排序优化：如何实现一个通用的、高性能的排序函数？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/16)
* [15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/17)
* [16 | 二分查找（下）：如何快速定位IP对应的省份地址？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/18)
* [17 | 跳表：为什么Redis一定要用跳表来实现有序集合？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/19)
* [18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/20)
* [19 | 散列表（中）：如何打造一个工业级水平的散列表？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/21)
* [20 | 散列表（下）：为什么散列表和链表经常会一起使用？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/22)
* [21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/23)
* [22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/24)
* [23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/25)
* [24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？](https://github.com/foreverZ133/Beauty-of-Data-Structure-and-Algorithms/issues/26)
* 未完待续
